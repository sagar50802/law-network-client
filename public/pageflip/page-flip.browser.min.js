// public/pageflip/page-flip.browser.min.js
// Simple custom PageFlip engine for your app.
// - Double-page 3D style on desktop (CSS animations)
// - Single page on small screens (CSS handles layout)
// - Click arrows + swipe to flip
// - API compatible with your React code: flipNext(), flipPrev(),
//   turnToPage(page), getState(), on("flip", handler), destroy()

(function (global) {
  class PageFlip {
    constructor(element, options) {
      if (!element) {
        throw new Error("PageFlip: container element is required");
      }

      this.root = element;
      this.opts = Object.assign(
        {
          width: 800,
          height: 600,
          flippingTime: 700,
          showCover: false,
        },
        options || {}
      );

      this.pages = [];
      this.currentPage = 0; // index of left page in spread
      this.isFlipping = false;
      this.handlers = {};

      this._setupDOM();
      this._setupEvents();
    }

    /* ---------- DOM SETUP ---------- */
    _setupDOM() {
      this.root.innerHTML = "";
      this.root.classList.add("pf-root");

      // left page
      this.leftPage = document.createElement("div");
      this.leftPage.className = "pf-page left";
      this.leftImg = document.createElement("img");
      this.leftPage.appendChild(this.leftImg);

      // right page
      this.rightPage = document.createElement("div");
      this.rightPage.className = "pf-page right";
      this.rightImg = document.createElement("img");
      this.rightPage.appendChild(this.rightImg);

      this.root.appendChild(this.leftPage);
      this.root.appendChild(this.rightPage);

      // Navigation arrows
      this.prevArrow = document.createElement("button");
      this.prevArrow.type = "button";
      this.prevArrow.className = "pf-arrow pf-arrow-left";
      this.prevArrow.setAttribute("aria-label", "Previous page");
      this.prevArrow.innerHTML = "&#8592;";

      this.nextArrow = document.createElement("button");
      this.nextArrow.type = "button";
      this.nextArrow.className = "pf-arrow pf-arrow-right";
      this.nextArrow.setAttribute("aria-label", "Next page");
      this.nextArrow.innerHTML = "&#8594;";

      this.root.appendChild(this.prevArrow);
      this.root.appendChild(this.nextArrow);
    }

    _setupEvents() {
      // Arrows
      this.prevArrow.addEventListener("click", () => this.flipPrev());
      this.nextArrow.addEventListener("click", () => this.flipNext());

      // Swipe / drag
      let startX = null;
      this.root.addEventListener("pointerdown", (e) => {
        startX = e.clientX;
      });

      this.root.addEventListener("pointerup", (e) => {
        if (startX == null) return;
        const dx = e.clientX - startX;
        if (Math.abs(dx) > 40) {
          if (dx < 0) this.flipNext();
          else this.flipPrev();
        }
        startX = null;
      });

      this.root.addEventListener("pointercancel", () => {
        startX = null;
      });
    }

    /* ---------- PUBLIC API ---------- */

    loadFromImages(imageUrls) {
      if (!Array.isArray(imageUrls)) {
        throw new Error("PageFlip.loadFromImages: parameter must be an array");
      }
      this.pages = imageUrls.slice();
      this.currentPage = 0;
      this._renderSpread();
    }

    flipNext() {
      if (!this.pages.length) return;
      // Each spread advances by 2 pages (left+right)
      const target = Math.min(this.currentPage + 2, this.pages.length - 1);
      if (target === this.currentPage) return;
      this._doFlip("next", target);
    }

    flipPrev() {
      if (!this.pages.length) return;
      const target = Math.max(this.currentPage - 2, 0);
      if (target === this.currentPage) return;
      this._doFlip("prev", target);
    }

    turnToPage(pageIndex) {
      if (!this.pages.length) return;
      if (typeof pageIndex !== "number") return;
      if (pageIndex < 0 || pageIndex >= this.pages.length) return;

      const direction = pageIndex > this.currentPage ? "next" : "prev";
      if (pageIndex === this.currentPage) return;
      this._doFlip(direction, pageIndex);
    }

    getState() {
      return { currentPage: this.currentPage };
    }

    on(name, handler) {
      if (!this.handlers[name]) this.handlers[name] = [];
      this.handlers[name].push(handler);
    }

    destroy() {
      this.root.innerHTML = "";
      this.pages = [];
      this.handlers = {};
      this.isFlipping = false;
    }

    /* ---------- INTERNAL ---------- */

    _emit(name, payload) {
      const list = this.handlers[name] || [];
      for (const fn of list) {
        try {
          fn(payload);
        } catch (err) {
          console.error("PageFlip handler error:", err);
        }
      }
    }

    _renderSpread() {
      if (!this.pages.length) {
        this.leftImg.removeAttribute("src");
        this.rightImg.removeAttribute("src");
        return;
      }

      const leftIndex = this.currentPage;
      const rightIndex = Math.min(this.currentPage + 1, this.pages.length - 1);

      this.leftImg.src = this.pages[leftIndex];

      if (rightIndex !== leftIndex) {
        this.rightPage.style.display = "";
        this.rightImg.src = this.pages[rightIndex];
      } else {
        // Last single page â€“ hide right on desktop too
        this.rightPage.style.display = "none";
        this.rightImg.removeAttribute("src");
      }

      this._emit("flip", { data: this.currentPage });
    }

    _doFlip(direction, targetPage) {
      if (this.isFlipping) return;
      if (!this.pages.length) return;

      this.isFlipping = true;
      const cls = direction === "next" ? "flip-next" : "flip-prev";
      this.root.classList.add(cls);

      const onAnimEnd = () => {
        this.leftPage.removeEventListener("animationend", onAnimEnd);
        this.root.classList.remove(cls);

        this.currentPage = targetPage;
        this._renderSpread();

        this.isFlipping = false;
      };

      // we rely on left page animation; it's active for both directions
      this.leftPage.addEventListener("animationend", onAnimEnd, { once: true });
    }
  }

  // expose globally
  global.PageFlip = PageFlip;
})(typeof window !== "undefined" ? window : this);
