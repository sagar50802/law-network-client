/*!
 * StPageFlip - v2.3.3
 * https://github.com/Nodlik/StPageFlip
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).PageFlip={})}(this,(function(t){"use strict";
/** utils **/
function e(t,e){return Object.keys(e).forEach((function(i){t[i]=e[i]})),t}function i(t){return t instanceof HTMLElement}function s(t){return"string"==typeof t||t instanceof String}function n(t){return t&&t instanceof HTMLImageElement}
function r(t){return t instanceof HTMLCanvasElement}function o(t){return t&&t instanceof HTMLVideoElement}
/** DOM helper **/
function a(t){return document.querySelector(t)}
/** vector **/
class h{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}copy(t){return this.x=t.x,this.y=t.y,this}}
/** point **/
class l{constructor(t=0,e=0){this.x=t,this.y=e}}
/** page states **/
var c;(c||(c={})).USER_FOLD="user_fold",c.TURNING="turning",c.ACTIVE="active",c.IDLE="idle";
/** angle math **/
function d(t){return t*Math.PI/180}
/** page area **/
class u{constructor(t,e,i,s){this.pageWidth=t,this.pageHeight=e,this.w=i,this.h=s}}
/** canvas drawer **/
class p{constructor(t,e,i){this.element=t,this.height=e,this.width=i;this.ctx=t.getContext("2d")}clear(){this.ctx.clearRect(0,0,this.width,this.height)}}

/** Flip managing **/
class f{constructor(t,e){this.parent=t,this.image=e,this.state=c.IDLE,this.angle=0,this.target=0,this.corner=new h,this.position=new h}setTarget(t){this.target=t}update(){if(this.state!==c.TURNING)return!1;let t=this.target-this.angle;return Math.abs(t)<.001?(this.angle=this.target,this.state=c.IDLE,!0):(this.angle+=.2*t,!1)}}

/** DOM sizes **/
function g(t){let e=t.getBoundingClientRect();return{width:e.width,height:e.height,top:e.top,left:e.left}}

/** main PageFlip class **/
class m{
  constructor(t,e={}){
    if(!i(t))throw new Error("Container is not HTML element");
    this._renderRef=this._render.bind(this);
    this.settings=e;
    this.container=t;
    this.loadFinish=!1;
    this.turning=!1;
    this.blocks=[];
    this.pages=[];
    this.imageLoadPromises=[];
    this._init();
  }

  _init(){
    this._setOptions();
    this._createDOM();
    this._setupEvents();
    this._loop();
  }

  _setOptions(){
    const t={
      width:600,
      height:800,
      size:"stretch",
      maxShadowOpacity:.5,
      drawShadow:!0,
      flippingTime:800,
      showCover:!1,
      usePortrait:!1,
      mobileScrollSupport:!0,
      startPage:0
    };
    this.opts=e(t,this.settings||{});
  }

  _createDOM(){
    this.wrapper=document.createElement("div");
    this.wrapper.className="stf__wrapper";
    this.container.innerHTML="";
    this.container.appendChild(this.wrapper);

    this.canvas=document.createElement("canvas");
    this.ctx=this.canvas.getContext("2d");
    this.wrapper.appendChild(this.canvas);
  }

  _loadImages(t){
    return t.map((e,i)=>new Promise((s,n)=>{
      const r=new Image;
      r.onload=()=>s(r);
      r.onerror=()=>n("image load failed");
      r.src=e;
    }));
  }

  loadFromImages(t){
    if(!Array.isArray(t))throw new Error("Images must be array");
    this.imageURLs=t;
    this.imageLoadPromises=this._loadImages(t);
    Promise.all(this.imageLoadPromises).then(e=>{
      this.images=e;
      this._buildPages();
      this.loadFinish=!0;
    });
  }

  _buildPages(){
    this.pages=[];
    for(let t=0;t<this.images.length;t++){
      this.pages.push({
        img:this.images[t],
        state:c.IDLE
      });
    }
    this.currentPage=this.opts.startPage||0;
  }

  _setupEvents(){
    this.wrapper.addEventListener("click",t=>{
      if(!this.loadFinish)return;
      const e=t.clientX-g(this.wrapper).left;
      e>this.wrapper.clientWidth/2?this.flipNext():this.flipPrev();
    });

    this.wrapper.addEventListener("touchstart",t=>{
      this._touchX=t.touches[0].clientX;
    });

    this.wrapper.addEventListener("touchend",t=>{
      let e=t.changedTouches[0].clientX-this._touchX;
      e<-50?this.flipNext():e>50&&this.flipPrev();
    });
  }

    flipNext(){
    if(!this.loadFinish)return;
    let t=this.currentPage;
    if(t>=this.pages.length-1)return;
    this.currentPage++;
    this.turning=!0;
  }

  flipPrev(){
    if(!this.loadFinish)return;
    let t=this.currentPage;
    if(t<=0)return;
    this.currentPage--;
    this.turning=!0;
  }

  turnToPage(t){
    if(!this.loadFinish)return;
    if(t<0||t>=this.pages.length)return;
    this.currentPage=t;
    this.turning=!0;
  }

  getState(){
    return{currentPage:this.currentPage}
  }

  _resizeCanvas(){
    const t=this.wrapper.clientWidth,
          e=this.wrapper.clientHeight;
    this.canvas.width=t;
    this.canvas.height=e;
  }

  _render(){
    if(!this.loadFinish)return;
    this._resizeCanvas();

    const t=this.currentPage,
          e=this.pages[t];

    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
    const i=e.img;

    let s=this.canvas.width,
        n=this.canvas.height;

    this.ctx.save();
    this.ctx.drawImage(i,0,0,s,n);
    this.ctx.restore();

    this.turning=!1;
  }

  _loop(){
    requestAnimationFrame(()=>{
      this._renderRef();
      this._loop();
    });
  }

  on(){}

  destroy(){
    cancelAnimationFrame(this._renderRef);
    this.wrapper.innerHTML="";
  }
}

t.PageFlip=m,Object.defineProperty(t,"__esModule",{value:!0});
}));
 
